## S+CSP2025模拟赛8

### A. 输出字符串

纯模拟题，题意懒得打了。。。

```cpp
#include <bits/stdc++.h>
#define int int64_t

int P[26];
std::vector<std::string> V[26];

signed main() {
    freopen("zigzag.in", "r", stdin);
    freopen("zigzag.out", "w", stdout);

    int n, q;
    std::string S;

    std::cin >> n >> q;

    for (int i = 1; i <= n; i++) {
        std::cin >> S;
        V[S[0] - 'a'].push_back(S);
    }

    for (int i = 0; i < 26; i++) std::sort(V[i].begin(), V[i].end());

    for (int i = 1; i <= q; i++) {
        char ch;
        std::cin >> ch;

        std::cout << V[ch - 'a'][P[ch - 'a']] << "\n";
        P[ch - 'a'] += 1;
        P[ch - 'a'] %= V[ch - 'a'].size();
    }

    return 0;
}
```

### B. 最优排列翻转

给定一排列 $\{p_1,\dots,p_n\}$，对于全部 $1\leqslant l\leqslant r\leqslant n$，求将 $[p_l,\dots,p_r]$ 翻转后最多能有多少个 $p_i$ 满足 $i$？

做法：显然这个东西需要枚举一维，枚举 $l$ 还是枚举 $r$ 都非常不可做。于是考虑逆向思维。反转的区间要满足什么条件才能让 $p_i$ 变到正确的位置上？答案只和区间是否覆盖 $p_i$ 和区间的中点有关。因此我们只需要枚举中点，显然此时确定中点情况下左右端点必有一个是 $p_i$，因为如果多出来一点一定不会让答案增加。贪心即可。$\mathcal{O}(n)$。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 524288;

int n, A[N], P[N];
int Prefix[N];
std::vector<int> Posit[N];
std::vector<int> Space[N];

int Sum(int l, int r) {
    if (l > r)
        return 0;
    if (l < 1)
        return Prefix[r];
    if (r < 1)
        return 0;
    if (r > n)
        r = n;
    if (l > n)
        return 0;
    int x = Prefix[r];
    return x - Prefix[l - 1];
}

int Abs(int x) {
    if (x < 0)
        return -x;
    return x;
}

signed main() {
    freopen("reverse.in", "r", stdin);
    freopen("reverse.out", "w", stdout);

    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cin >> n;
    for (int i = 1; i <= n; i++) {
        std::cin >> A[i];
        P[A[i]] = i;
    }

    for (int i = 1; i <= n; i++) Prefix[i] = Prefix[i - 1] + (A[i] == i);

    for (int i = 1; i <= n; i++) {
        int t = Abs(i - P[i]);
        if (t & 1) {
            int x = std::min(i, P[i]) + t / 2;
            Space[x].push_back(i);
        } else {
            int x = std::min(i, P[i]) + t / 2;
            Posit[x].push_back(i);
        }
    }

    for (int i = 1; i <= n; i++) {
        std::sort(Posit[i].begin(), Posit[i].end(), [&](int a, int b) {
            int distA = Abs(a - i);
            int distB = Abs(b - i);
            return distA < distB;
        });
        std::sort(Space[i].begin(), Space[i].end(), [&](int a, int b) {
            a = std::min(a, P[a]);
            b = std::min(b, P[b]);
            int distA = Abs(a - i);
            int distB = Abs(b - i);
            return distA < distB;
        });
    }

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < Posit[i].size(); j++) {
            int endval = Posit[i][j];
            int l = std::min(endval, P[endval]);
            int r = std::max(endval, P[endval]);
            ans = std::max(ans, Sum(1, l - 1) + Sum(r + 1, n) + j + 1);
        }
        for (int j = 0; j < Space[i].size(); j++) {
            int endval = Space[i][j];
            int l = std::min(endval, P[endval]);
            int r = std::max(endval, P[endval]);
            ans = std::max(ans, Sum(1, l - 1) + Sum(r + 1, n) + j + 1);
        }
    }

    std::cout << ans - Prefix[n] << "\n";

    return 0;
}
```

### C. 比赛

给定一棵以 $1$ 为根的树，有 $m$ 个跳板，每个跳板可以在 $p_i$ 花费 $v_i$ 的代价向上跳 $1\sim w_i$ 次。现有 $q$ 次询问，问在上述规则下 $x$ 到 $1$ 的最少花费？数据保证有解。

解法：有一个显然的 $\text{DP}$：

$\text{dp}_i = \min(\min(\text{ancestors}(i,w_j))+v_i)(p_j=i,w_j,v_j)$。

翻译一下：$\text{dp}_i$ 的决策点是 $i$ 的 $1 \sim w_j$ 级祖先。

显然，树链剖分优化即可。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int L = 32;
const int N = 262144;
const int INF = (1ll << 55);

int n, m, q;
std::vector<signed> G[N];
std::vector<std::pair<signed, int>> Maps[N];

int Siz[N], Dep[N], Par[N], Heavy[N];
int Dfn[N], Lis[N], Chain[N], cntDfn;
signed ST[L][N];
int Ans[N];

struct Segmentree {
    int l, r, mid;
    int minval;
    Segmentree *ls, *rs;

    Segmentree(int ll, int rr) {
        l = ll, r = rr;
        mid = (l + r) / 2;
        minval = INF;

        if (l != r) {
            ls = new Segmentree(l, mid);
            rs = new Segmentree(mid + 1, r);
        }
    }

    void Modify(int pos, int cnt) {
        if (l == r) {
            minval = cnt;
        } else {
            if (pos <= mid)
                ls->Modify(pos, cnt);
            else
                rs->Modify(pos, cnt);
            minval = std::min(ls->minval, rs->minval);
        }
    }

    int Query(int ll, int rr) {
        if (ll <= l && r <= rr) {
            return minval;
        } else {
            if (ll <= mid && mid < rr)
                return std::min(ls->Query(ll, rr), rs->Query(ll, rr));

            if (ll <= mid)
                return ls->Query(ll, rr);

            return rs->Query(ll, rr);
        }
    }
} * DP;

void DFSBuild(int u, int from, int dep) {
    Par[u] = from;
    Dep[u] = dep;
    Siz[u] = 1;

    for (auto v : G[u])
        if (v != from) {
            DFSBuild(v, u, dep + 1);
            Siz[u] += Siz[v];

            if (Siz[v] > Siz[Heavy[u]])
                Heavy[u] = v;
        }
}

void DFSChain(int u, int top) {
    Chain[u] = top;
    Dfn[u] = ++cntDfn;
    Lis[cntDfn] = u;

    if (Heavy[u]) {
        DFSChain(Heavy[u], top);

        for (auto v : G[u])
            if (v != Par[u] && v != Heavy[u])
                DFSChain(v, v);
    }
}

int Ancestor(int u, int layer) {
    for (int i = 0; i <= 25; i++)
        if (layer >> i & 1)
            u = ST[i][u];
    return u;
}

void TreeDP(int u) {
    if (u != 1) {
        Ans[u] = INF;
        for (auto e : Maps[u]) {
            int cost = e.second;
            int layer = std::min((int)(e.first), Dep[u]);

            int v = Ancestor(u, layer);
            int copyu = u;

            while (Chain[copyu] != Chain[v])
                Ans[u] = std::min(Ans[u], DP->Query(Dfn[Chain[copyu]], Dfn[copyu]) + cost),
                copyu = Par[Chain[copyu]];

            Ans[u] = std::min(Ans[u], DP->Query(Dfn[v], Dfn[copyu]) + cost);
        }

        DP->Modify(Dfn[u], Ans[u]);
    }

    for (auto v : G[u]) {
        if (v != Par[u])
            TreeDP(v);
    }
}

signed main() {
    freopen("match.in", "r", stdin);
    freopen("match.out", "w", stdout);

    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cin >> n >> m >> q;

    int u, v, w;
    for (int i = 1; i < n; i++) {
        std::cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    for (int i = 1; i <= m; i++) {
        std::cin >> u >> v >> w;
        Maps[u].emplace_back(v, w);
    }

    DFSBuild(1, 0, 0);
    DFSChain(1, 1);

    for (int i = 1; i <= n; i++) ST[0][i] = Par[i];

    for (int i = 1; 1 << i <= n; i++)
        for (int j = 1; j <= n; j++) ST[i][j] = ST[i - 1][ST[i - 1][j]];

    DP = new Segmentree(1, n);
    DP->Modify(Dfn[1], 0);
    Ans[1] = 0;

    TreeDP(1);

    while (q--) {
        std::cin >> u;
        std::cout << Ans[u] << "\n";
    }

    return 0;
}
```

### D. 圣杯战争

给定一张无向带权图，每个点有颜色，$q$ 次修改，每次修改完后输出权值最小的满足两个端点颜色不同的边的权值。

结论：答案一定在最小生成树上；

证明：

1. 假如原图没有环，则原图就是原图的最小生成树，证明完毕；
2. 对于一个环，环上最大权值呃那条边无意义，以三个点的环为例，反证法：

$a \to b \to c \to a \to \dots$

假设 $\text{weight}(a \to b) > \text{weight}(b \to c) > \text{weight}(c \to a)$；

如果 $\text{weight}(a \to b)$ 是答案，那么 $\text{col}(a) \neq \text{col}(b)$，又因为 $\text{weight}(b \to c)$ 不是答案，意味着 $\text{col}(b) = \text{col}(c)$，
$c \to a$ 同理，$\text{col}(c) = \text{col}(a)$，显然这是不可能的。

因此前提错误，即 $a \to b$ 不可能是答案，更多条边同理。

不断破圈，最后留下的必然就是最小生成树。

因此 $m$ 条边中只有 $n - 1$ 条是有意义的。

我们成功将原图变成了一棵树。

然后我们考虑对于每个节点维护它的所有子节点的颜色构成的权值集合，支持：

- 插入 $(\text{color}, \text{weight})$；
- 删除 $(\text{color}, \text{weight})$；
- 询问 $\text{col} \neq \text{color}, $ 最小的 $\text{weight}$。

我们用线段树，以颜色为下标，子节点维护 $\text{multiset}$，内部节点维护 $\text{minval}$ 即可。

每次修改只会修改一个集合，即其父亲的集合。

再维护 $\text{Ans}$ 数组，$\text{Ans}(i)$ 表示 $i$ 及其儿子的构成的树的答案。

每次修改只会更改 $u$ 和 $\text{parent}(u)$ 的 $\text{Ans}$，于是 $\text{Ans}$ 就是单点修改、全局查询。线段树即可。

于是就做完了。

[P3665 [USACO17OPEN] Switch Grass P](https://www.luogu.com.cn/problem/P3665)

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 1048576;
const int INF = 1ll << 56;

int n, m, k, q;
int F[N];

std::vector<
    std::tuple<int, int, int>
    > V;

int SetFind(int u) {
    if (F[u] == u) return u;
    return F[u] = SetFind(F[u]);
}

std::vector<
    std::pair<int, int>
    > Tree[N];

int Parent[N], PWeight[N];
int Color[N];

void DFSearch(int u, int from, int fweight) {
    Parent[u] = from;
    PWeight[u] = fweight;

    for (auto e : Tree[u]) {
        int v = e.first;
        int w = e.second;
        if (v != from) 
            DFSearch(v, u, w);
    }
}

struct Answer {
    Answer* Ls, *Rs;
    int l, r, mid, min;

    Answer(int ll, int rr) {
        l = ll; r = rr;
        mid = l + r >> 1;
        min = INF;
        
        if (l == r) {
            Ls = Rs = nullptr;
        } else {
            Ls = new Answer(l, mid);
            Rs = new Answer(mid + 1, r);
        }
    }

    void Modify(int pos, int to) {
        if (l == r) {
            min = to;
        } else {
            if (pos <= mid)
                Ls->Modify(pos, to);
            else
                Rs->Modify(pos, to);
            min = std::min(Ls->min, Rs->min);
        }
    }
} *Ans;

struct ColorSet {
    std::multiset<int>* Set;
    ColorSet* Ls, *Rs;
    int l, r, mid, min;

    ColorSet(int ll, int rr) {
        l = ll; r = rr;
        mid = l + r >> 1;
        Set = nullptr;
        Ls = Rs = nullptr;
        min = INF;

        if (l == r)
            Set = new 
                std::multiset<int>();
    }

    void Maintain() {
        if (!Set) {
            min = INF;
            if (Ls) 
                min = std::min(min, Ls->min);
            if (Rs)
                min = std::min(min, Rs->min);
        }
    }

    void Insert(int col, int wei) {
        if (l == r) {
            Set->insert(wei);
            min = *Set->begin();
        } else {
            if (col <= mid) {
                if (!Ls) 
                    Ls = new ColorSet(l, mid);
                Ls->Insert(col, wei);
            } else {
                if (!Rs)
                    Rs = new ColorSet(mid + 1, r);
                Rs->Insert(col, wei);
            } Maintain();
        }
    }

    void Remove(int col, int wei) {
        if (l == r) {
            Set->erase(Set->find(wei));
            if (Set->empty())
                min = INF;
            else
                min = *Set->begin();
        } else {
            if (col <= mid)
                Ls->Remove(col, wei);
            else
                Rs->Remove(col, wei);
            Maintain();
        }
    }

    int QueryMin(int ll, int rr) {
        if (ll > rr) return INF;
        if (ll <= l && r <= rr) {
            return min;
        } else {
            if (ll <= mid && Ls && mid < rr && Rs)
                return std::min(
                    Ls->QueryMin(ll, rr),
                    Rs->QueryMin(ll, rr)
                );
            
            if (ll <= mid && Ls)
                return Ls->QueryMin(ll, rr);
            
            if (mid < rr && Rs)
                return Rs->QueryMin(ll, rr);
            
            return INF;
        }
    }
} *Cs[N];

signed main() {
    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cin >> n >> m >> k >> q;

    for (int i = 1; i <= n; i++)
        F[i] = i;

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        V.emplace_back(w, u, v);
    }

    Ans = new Answer(1, n);
    std::sort(V.begin(), V.end());

    for (int i = 0; i < m; i++) {
        int w = std::get<0>(V[i]);
        int u = std::get<1>(V[i]);
        int v = std::get<2>(V[i]);

        if (SetFind(u) != SetFind(v)) {
            F[SetFind(u)] = SetFind(v);
            Tree[u].emplace_back(v, w);
            Tree[v].emplace_back(u, w);
        }
    }

    for (int i = 1; i <= n; i++)
        std::cin >> Color[i];

    DFSearch(1, 0, 0);

    auto Update = [&] (int x) {
        Ans->Modify(x, std::min(
            Cs[x]->QueryMin(1, Color[x] - 1),
            Cs[x]->QueryMin(Color[x] + 1, k)
        ));
    };

    for (int i = 1; i <= n; i++) {
        Cs[i] = new ColorSet(1, k);

        for (auto e : Tree[i]) {
            int v = e.first;
            int w = e.second;

            if (v != Parent[i])
                Cs[i]->Insert(Color[v], w);
        }
    }

    for (int i = 1; i <= n; i++)
        Update(i);

    while (q -- ) {
        int u, change;
        std::cin >> u >> change;

        int p = Parent[u];

        if (p) {
            Cs[p]->Remove(Color[u], PWeight[u]);
            Cs[p]->Insert(change, PWeight[u]);
            Update(p);
        }   

        Color[u] = change;
        Update(u);

        std::cout << Ans->min << "\n";
    }

    return 0;
}
```