## S+20250814测试

### A. 交换序列

题意：给定长度 $n$ 的排列 $A$，问是否可以通过至多一次交换使其变为 $1,2,\dots,n$。

省流：STL 真好用。

解法：$n\leqslant 50$，枚举 $i,j$ `std::swap(i, j)` 然后 `std::is_sorted` 即可。

### B. 最小绝对值

题意：给定 $D\leqslant 2\times10^{12}$，求对于所有非负整数对 $(x,y)$，$\min\{|x^2+y^2-D|\}$。

解法：存在即合理！$D \leqslant 10^{12}$ 考虑根号做法。不难想到枚举 $x$，$y$ 只有可能是 $\lfloor\sqrt{D-x^2}\rfloor$ 或 $\lceil\sqrt{D-x^2}\rceil$。

### C. 3色骨牌

题意：给定 $n\leqslant 52$ 的 $2$ 行 $n$ 列字符矩阵，其中相同字母的为同一块骨牌，每个骨牌要么占用一行两列要么占用两行一列，请问将所有骨牌染成三种颜色且保证相邻骨牌颜色不同的染色方案数。

解法：显然如果骨牌们要成功拼成两行 $n$ 列字符矩阵，那么骨牌分布一定形如：

- $(\texttt{a})\times n + (\texttt{bb})\times m$ 自由组合
- $(\texttt{a})\times n + (\texttt{cc})\times m$ 自由组合

一定可以分成“平躺”和“站立”的两种，乘法原理统计。

|上一次的类型\当前类型|“平躺”|“站立”|
|:--|:--|:--|
|无|$\times 6$|$\times 3$|
|“平躺”|$\times 3$|$\times 1$|
|“站立”|$\times 3$|$\times 2$|

分别相乘即可。

### D. 翻转行列

给定 $n,m,r,c$，在 $n\times m$  的 $01$ 矩阵（初始全零）中选择 $r$ 行 bit-flip（可以重复），$c$ 列 bit-flip（可以重复）。问所有满足条件的选法中有多少满足 bit-flip 之后矩阵恰好 $s$ 个 $1$？

不难发现最终矩阵的 $1$ 一定可以拼凑成一个矩阵，一定来源于 bit-flip 奇数次的点。

显然 $r$ 会有很多多出来没用的，因为 $n,m\leqslant 10^3$，考虑枚举有多少行选择次数为奇数、多少列选择次数为奇数，于是我们就可以计算出此时 $1$ 的个数，再套用组合数便可计算总贡献，汇总相加即可。

赛时脑抽了没想到。

### E. 键帽

给定 $n\leqslant 10^6$，和 $k\leqslant n$，问有几个长度为 $n$ 的由 $26$ 英文字母组成的字符串满足其中不包含连续 $k + 1$ 个元音？对 $10^9+7$ 取模。

$\text{dp}(i,j)$ 表示长度为 $i$，最后有 $j$ 个元音的满足不包含连续 $k+1$ 个元音的字符串有几个。

$$
\text{dp}(i,j) \gets \text{dp}(i-1,j-1)\times 5\newline
\text{dp}(i,0) \gets \sum\text{dp}(i-1,j)\times 21 (0\leqslant j \leqslant k)
$$

这是暴力的 $\mathcal{O}(nk)$ 做法。

不难发现 $\text{dp}(i,j) (j\neq 0)$ 的来源只有一种，那么就可以直接 pow 算出来，即：
$\text{dp}(i,j)=\text{dp}(i-j,0)\times 5^j$。

于是我们就成功把状态压成了一维。只需要存储 $\text{dp}(i,0)$ 即可。

但是此时转移还是 $\mathcal{O}(k)$，我们只需要一个次方的前缀和维护即可。

具体的 $s(i)=\sum 5^{n-i}\text{dp}(i,0)$，然后取用使类似普通前缀和查询即可。

### F. 偷金计划

给定一个无向图、$k$ 个关键点和 $Q$ 次询问。

每次询问 $S,T$ 回答满足“存在一条从 $S$ 到 $T$ 路径，使得这条路径上的每个点都距离最近关键点的距离超过 $x$”的最大的非负整数 $x$，若不存在输出 $0$。

直接做十分不可能。于是考虑离线。一开始真的想过“整体”二分，但是没啥意义（

首先我们考虑预处理每个点到最近关键点距离，没有负权边直接建虚拟源点跑 dijkstra 即可。

然后我们按照每个点的 dist 依次“加入”这些点。想象一开始 $c=0$，图上没有任何边，全部是散点，对应 $x=+\infty$ 时不能经过任何点。随后 $c$ 逐渐增大逐渐加入点和边。

但是如何维护询问呢？询问的 $S,T$ 在当前的 $c$ 下已经可以通了，这个可以用并查集来维护，维护时在每个集合的根节点维护 $\text{query}$ vector，merge 时遍历**较小**的根节点的 $\text{query}$ 如果在这次 merge 中询问的 $S,T$ “团聚”了，更新答案数组。这便是启发式合并的经典套路，不难发现以上算法复杂度 $\mathcal{O}(n\log n)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
#define int int64_t

constexpr int N = 131072;

int n, m, k, q;
std::vector<std::pair<int, int> > G[N];
int D[N];
bool Vis[N];
std::vector<int> Guards; 
std::vector<std::pair<int, int> > Ans[N];
int F[N], FAns[N];
std::pair<int, int> Asks[N];

int Find(int x) {
	if (F[x] == x) return x;
	return F[x] = Find(F[x]);
}

void Merge(int x, int y, int res) {
	x = Find(x);
	y = Find(y);
	if (x != y) {
		if (Ans[x].size() < Ans[y].size()) 
			std::swap(x, y);
		for (auto i : Ans[y]) {
			int va = i.first;
			int vb = i.second;
			Ans[x].push_back(i);
			if (Find(va) == x) 
				FAns[vb] = res;
		} Ans[y].clear();
		F[y] = x;	
	} 	
}

bool DCompare(int u, int v) {
	if (D[u] != D[v]) return D[u] > D[v];
	return u > v;
}

signed main() {
	std::cin.tie(nullptr);
	std::cin.sync_with_stdio(false);
	
	std::cin >> n >> m;
	for (int i = 1, u, v, w; i <= m; i++) {
		std::cin >> u >> v >> w;
		G[u].emplace_back(v, w);
		G[v].emplace_back(u, w);
	}
	
	std::cin >> k;
	for (int i = 1, x; i <= k; i++) {
		std::cin >> x;
		Guards.push_back(x);
		G[0].emplace_back(x, 0ll);
	}
	
	for (int i = 1; i < N; i++)
		D[i] = (1ll << 50);
		
	std::priority_queue<
		std::pair<int, int>,
		std::vector<std::pair<int, int> >, 
		std::greater<std::pair<int, int> >
	> queue;
	
	queue.emplace(D[0], 0ll);
	
	while (queue.size()) {
		int u = queue.top().second;
		queue.pop();
		
		if (Vis[u]) continue;
		Vis[u] = true;
		
		for (auto e : G[u]) {
			int v = e.first;
			int w = e.second;
			if (D[v] > D[u] + w) {
				D[v] = D[u] + w;
				queue.emplace(D[v], v);
			}
		}
	}
	
	for (int i = 1; i <= n; i++)
		F[i] = i;
	
	std::cin >> q;
	for (int i = 1; i <= q; i++) {
		std::cin >> Asks[i].first >> Asks[i].second;
		Ans[Asks[i].first].emplace_back(Asks[i].second, i);
		Ans[Asks[i].second].emplace_back(Asks[i].first, i);
	}
	
	std::vector<int> V;
	for (int i = 1; i <= n; i++)
		V.push_back(i);
	
	std::sort(V.begin(), V.end(), 
		DCompare);
	
	int cur = (1ll << 50); 
	for (int i = 0; i < V.size(); i++) {
		cur = D[V[i]] - 1;
		for (auto e : G[V[i]]) {
			int v = e.first;
			int w = e.second;
			if (D[v] > cur) 
				Merge(V[i], v, cur);
		}
	}
	
	for (int i = 1; i <= q; i++)
		if (FAns[i] < 0) 
			std::cout << "0\n";
		else
			std::cout << FAns[i] << "\n";
	
	return 0;
}
```

赛时切掉。

