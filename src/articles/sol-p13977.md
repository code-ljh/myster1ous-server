## 题解：P13977 数列分块入门 2

### 题意

给定一个长度为 $n(1\leqslant n\leqslant 2\times10^5)$ 的整数数列 $a_1,a_2,\dots,a_n$，你需要维护这个数列，支持以下几种操作：

- `0 l r x` 将 $a_l,a_{l+1},\dots,a_r$ 全部加上 $x$ 并赋值。
- `1 l r x` 问 $a_l,a_{l+1},\dots,a_r$ 中有多少个小于 $x^2$ 的数。

### 做法

本题名字直接写明了本题需要使用“数列分块”算法。

“数列分块”，简而言之就是把整个序列分成 $\mathcal{O}(\sqrt{n})$ 块。

例如 $n=8$ 块长为 $3$，序列划分为以下几块：

```plain
块(1) = [1, 3];
块(2) = [4, 6];
块(3) = [7, 8]; 非满块，因为到末尾了。
```

这样做有什么好处呢？好处就是这样就能把询问/修改的 $[l,r]$ 区间化成 $\mathcal{O}(\sqrt{n})$ 个整块和最多 $\mathcal{O}(\sqrt{n})$ 个单元素。

对于询问/修改的区间，如果 $l,r$ 都在同一块内，直接全部分成单元素。因为此时区间长度一定小于等于块长。通俗地讲就是直接暴力循环 $l \sim r$。

如果 $l,r$ 不在同一块里，比如还是 $n=8$ 块长为 $3$，此时 $l=2,r=7$ 时：

```plain
块(1) = [1, 3]; l 在这里
块(2) = [4, 6];
块(3) = [7, 8]; r 在这里
```

中间的第二块我们可以直接当成整块处理。这就为我们省下了很多时间。

在第一块及第三块与区间交的部分，我们仍然可以暴力。因为最多就是两倍的块长的大小。

---

对于 $0$ 操作，分出来的单元素我们暴力修改即可。关键在于整块怎么做？肯定不能也暴力，因为整块的总大小是 $\mathcal{O}(n)$ 级别。于是我们聪明地想到可以**打标记**来表示这一块被整体加了。在需要时也可以直接使用标记来处理/或下放标记到序列。线段树中也是这个标记，我们一般叫它**懒标记思想**。

注意不仅询问单元素的时候需要下放标记，修改的时候也要下放。当然本题也有不下放的写法但是我写的是下放的。

对于 $1$ 操作，分出来的单元素仍然是直接暴力（记得先下放懒标记）；

对于整块呢？我们必须像修改的时候一样 $\mathcal{O}(1)$ 找到。但是如果不预处理什么的话大概是办不到的。能快速查询“小于某个数的数量”的最简单方法便是直接排序，查询时二分即可。因此我们可以对于每个整块都维护一个排序后的数列，这样就可以了。

于是我们就做完了。

复杂度：$\mathcal{O}(n\sqrt{n}\log\sqrt{n})$。

注意开 `long long`，本题数据范围较大记得卡些常数。

```cpp
#include <bits/stdc++.h>
#define int long long
class FastInputStream {
	private:
		static const int BUFSIZE = 16384;
		std::streambuf *fb;
		char buf[BUFSIZE], *s, *t;
		
	public: FastInputStream() {
		fb = std::cin.rdbuf();
		s = t = buf;
	}
	
	public: char getc() {
		if (s == t) {
			s = buf;
			t = buf + fb->sgetn(buf, BUFSIZE);		
		}
		char get = *s;
		return s++, get;
	}
	
	public: template<class INT>
	void read(INT& x) {
		char ch = getc();
		int sign = 1; x = 0;
		while (!isdigit(ch)) {
			if (ch == '-') sign = -sign;
			ch = getc();
		}
		while (isdigit(ch)) {
			x = x * 10 + ch - '0';
			ch = getc();
		}
		x *= sign;
	}
	
	public: template<class INT, class ...ARGS>
	void read(INT& a, ARGS& ... args) {
		read(a);
		read(args ... );
	}
} input;

class FastOutputStream {
	private:
		static const int BUFSIZE = 16384;
		std::streambuf *fb;
		char buf[BUFSIZE], *s, *t;
		
	public: FastOutputStream() {
		fb = std::cout.rdbuf();
		s = buf, t = buf + BUFSIZE;
	}
	
	public: void write(char ch) {
		fb->sputc(ch);
	}
	
	public: void write(std::string s) {
		for (auto i : s) fb->sputc(i);
	}
	
	public: void write(const char *ch) {
		int ln = strlen(ch);
		for (int i = 0; i < ln; i++)
			fb->sputc(ch[i]);
	}
	
	public: template<class INT>
	void write(INT x) {
		int len = 0;
		static char stack[64];
		if (x < 0) {
			fb->sputc('-');
			x = -x;
		}
		if (!x) {
			fb->sputc('0');
			return;
		}
		while (x) {
			stack[len++] = x % 10 + '0';
			x /= 10;
		}
		for (int i = len - 1; i >= 0; i--)
			fb->sputc(stack[i]);
	}
	
	public: template<class INT, class ...ARGS>
	void write(INT a, ARGS ... args) {
		write(a);
		write(args ... );
	}
} output;

const int N = 262144;

int bs;

int _BR(int x) { return x * bs; }
int _BL(int x) { return (x - 1) * bs + 1; }
int _CD(int x) { return (x % bs ? x / bs + 1 : x / bs); }

int n, A[N], Lazytag[N], BL[N], BR[N], CD[N];
std::vector<int> Seq[N];

void Pushup(int block) {
    Seq[block].clear();
    for (int i = BL[block]; i <= BR[block]; i++)
        Seq[block].push_back(A[i]);
    std::sort(Seq[block].begin(), Seq[block].end());
}

void Pushdown(int block) {
    if (Lazytag[block]) {
        for (int i = BL[block]; i <= BR[block]; i++)
            A[i] += Lazytag[block];
        for (auto &i : Seq[block])
            i += Lazytag[block];
        Lazytag[block] = 0;
    }
}

signed main() {
    input.read(n);
    for (int i = 1; i <= n; i++)
        input.read(A[i]);
    
    bs = 500;

    for (int i = 1; i < N; i++)
        CD[i] = _CD(i);

    for (int i = 1; i <= CD[n]; i++) {
        BL[i] = _BL(i);
        BR[i] = _BR(i);
        Pushup(i);
    }
    
    for (int i = 1; i <= n; i++) {
        int opr, l, r, c;
        input.read(opr, l, r, c);

        if (opr == 0) {
            if (CD[l] == CD[r]) {
                Pushdown(CD[l]);
                for (int i = l; i <= r; i++)
                    A[i] += c;
                Pushup(CD[l]);
                continue;
            }

            Pushdown(CD[l]);
            Pushdown(CD[r]);

            int end = CD[r];
            for (int i = CD[l] + 1; i < end; i++)
                Lazytag[i] += c;
            
            end = BR[CD[l]];
            for (int i = l; i <= end; i++)
                A[i] += c;
            
            for (int i = BL[CD[r]]; i <= r; i++)    
                A[i] += c;
            
            Pushup(CD[l]); 
            Pushup(CD[r]);
        } else {
            c *= c;

            int sum = 0;
            if (CD[l] == CD[r]) {
                Pushdown(CD[l]);
                for (int i = l; i <= r; i++)
                    sum += A[i] < c;
                output.write(sum, '\n');
                continue;
            }

            Pushdown(CD[l]);
            Pushdown(CD[r]);
            
            int end = BR[CD[l]];
            for (int i = l; i <= end; i++)
                sum += A[i] < c;
            
            for (int i = BL[CD[r]]; i <= r; i++)    
                sum += A[i] < c;
            
            end = CD[r];
            for (int i = CD[l] + 1; i < end; i++) 
                sum += std::lower_bound(Seq[i].begin(), Seq[i].end(), c - Lazytag[i]) - Seq[i].begin();
            
            output.write(sum, '\n');
        }
    }

    return 0;
}
```

附：对拍器。

```cpp
#include <bits/stdc++.h>
#define int int64_t

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

int Randint(int l, int r) {
    std::uniform_int_distribution<int> D(l, r);
    return D(rnd);
}

int n = 200000;
int V = INT_MAX, V2 = INT_MIN;

signed main() {
    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cout << n << "\n";
    for (int i = 1; i <= n; i++)
        std::cout << Randint(V2, V) << " \n"[i == n];

    for (int i = 1; i <= n; i++) {
        std::cout << Randint(0, 1) << " ";
        int a = Randint(1, n), b = Randint(1, n);
        std::cout << std::min(a, b) << " " << std::max(a, b) << " " << Randint(V2, V) << "\n";
    }

    return 0;
}
```

```cpp
// checker.cpp
#include <bits/stdc++.h>
#define int long long

std::string filename = "code";

signed main() {    
    int tc = 0;
    while (true) {
        tc += 1;
        std::system((filename + "-gen.exe > "
			 + filename + ".in").c_str());
        std::system((filename + "-sol.exe < "
			 + filename + ".in > "
			 + filename + ".ans").c_str());
        
        int tfrom = clock();
        std::system((filename + ".exe < "
			 + filename + ".in > "
			 + filename + ".out").c_str());
        int tto = clock();

        bool flag = false;
        std::ifstream outin(filename + ".out");
        std::ifstream ansin(filename + ".ans");
        std::ifstream inpin(filename + ".in");
        
        std::string out, ans, all, ansall;
        int hashcode = 0;
        while (true) {
            bool bln = false;
            bln |= bool(std::getline(outin, out));
            bln |= bool(std::getline(ansin, ans));
            if (!bln) {
                break;
            } else {
                while (out.back() == ' ') out.pop_back();
                while (ans.back() == ' ') ans.pop_back();
                ansall += ans;
                if (out != ans) {
                    flag = true;
                    break;
                }
            }
        } 
        
        std::getline(inpin, all, '@');
        for (int i = 0; i < all.size(); i++)
        	hashcode = (hashcode * 997 + all[i]) % 998244353;
        
        if (flag == 0 || ansall == "SPEEDTEST") {
            std::cerr << "\033[32mAccepted #" << tc << " "
                 << (tto - tfrom) * 1.0 / CLOCKS_PER_SEC
                 << "s " << "\033[0m";
            std::cerr << "    info: (size="
                 << all.size() << "B, hash=" << hashcode << ")\n";
        } else {
            std::cerr << "\033[31mUnaccepted #" << tc << "\033[0m\n";
            return 0; 
        }
    }
    
    return 0;
}
```