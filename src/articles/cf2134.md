## Codeforces Round 1045 Div.2

好久没打过 Codeforces 补一场。

我 Rating 涨到 1720 打了估计必掉分。。。

结果居然涨分了。什么成分。

总体评价：Speedforces. 手速场，几乎全 ad-hoc。

### A. Painting With Two Colors

给定 $n,a,b$。

对于一个初始全 $0$ 的长度为 $n$ 的数组。

按顺序执行以下操作：

- 将原数组一段长度为 $a$ 的区间设置为 $1$。
- 将原数组一段长度为 $b$ 的区间设置为 $2$。

问最后时刻数组是否可以回文？$t\leqslant 500$ 组测试数据。

结论：简单题。

1. 如果 $b \geqslant a$，那么 $\text{Ans}(n,a,b) = \text{Ans}(n,n,b)$。
2. 如果 $(a-n)\equiv 0\pmod 2$，那么 $\text{Ans}(n,a,b)=\text{Ans}(n,n,b)$。
3. 如果 $(b-n)\equiv 0\pmod 2$，那么 $\text{Ans}(n,b,b)=\texttt{true}$。

随后就可以 $\mathcal{O}(t)$ 解决了。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int INF = 1145141919810ll;

int t, n, a, b;

signed main() {
    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cin >> t;

    while (t -- ) {
        std::cin >> n >> a >> b;

        if (a < b) a = n;

        if ((n - a) % 2 == 0 && (n - b) % 2 == 0) {
            std::cout << "YES\n";
        } else {
            std::cout << "NO\n";
        }
    }

    return 0;
}
```

### B. Add 0 or K

给定长度 $n$ 的数组 $a_1,a_2,\dots,a_n$ 和 $k$。

你可以将每一个 $a_i$ 加上 $p_i \times k$，其中 $0 \leqslant p_i \leqslant k$。

构造 $p$ 数组，满足操作后 $a_1,a_2,\dots,a_n$ 有公因数。

输出操作结束后的 $a$ 数组。

**可以证明这一定是可能的。**

结论：最终的公因数一定可以是 $k+1$。

考虑全部 $a_i \bmod (k+1)$。

$a_i \gets a_i + k \iff a_i \gets a_i - 1\pmod{k+1}$。

又因为 $a_i \bmod (k+1) \leqslant k$，最多减去 $k$ 次即可。做完了。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 131072;

signed main() {
    int n, a[N], k, t;

    std::cin >> t;

    while (t -- ) {
        std::cin >> n >> k;

        for (int i = 1; i <= n; i++)
            std::cin >> a[i];
        
        for (int i = 1; i <= n; i++) {
            int times = a[i] % (k + 1);
            std::cout << times * k + a[i] << 
                " \n"[i == n];
        }
    }

    return 0;
}
```

### C. Even larger.

给定长度 $n$ 的数组 $a_1,a_2,\dots,a_n$。

一个数组是好的，当且仅当对于任意长度大于等于 $2$ 区间 $a_l,a_{l+1},\dots,a_r$，其中偶数下标的 $a_i$ 之和大于等于其余 $a_i$ 之和。

你可以选定 $i(a_i \geqslant 1)$ 执行以下操作任意次：

- $a_i \gets a_i - 1$。

请问将给定数组变成好的至少需要多少次操作？

结论：对于 $n \geqslant 3$ 的情况，有意义的 $l,r$ 有且仅有 $r - l = 2$ 且 $(l,r)\equiv(1,1) \pmod 2$。

对于第一个满足 $a_{2i}\leqslant a_{2i-1}+a_{2i+1}$ 的 $i$，

- 优先减少右边。如果不能减少右边，减少左边。
- 这个贪心的正确性是显然的。

然后就做完了。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 262144;

int n, a[N], k, t;
signed main() {
    std::cin >> t;

    while (t -- ) {
        std::cin >> n;
        
        memset(a, 0, sizeof a);

        for (int i = 1; i <= n; i++)
            std::cin >> a[i];
        a[n + 1] = 0;        
        if (n == 2) {
            std::cout << std::max(0ll, a[1] - a[2]) << "\n";
        } else {
            int ans = 0;

            for (int i = 2; i <= n; i += 2) {
                if (a[i - 1] + a[i + 1] > a[i]) {
                    // std::cout << a[i - 1] << " " << a[i + 1] << " " << a[i] << ";\n";
                    int minus1 = std::min(
                        a[i + 1], a[i - 1] + a[i + 1] - a[i]);
                    ans += minus1; a[i + 1] -= minus1;
                    // std::cout << minus1 << "\n";

                    if (a[i - 1] + a[i + 1] > a[i]) {
                        int minus0 = std::min(
                            a[i - 1], a[i - 1] + a[i + 1] - a[i]);

                        ans += minus0; a[i - 1] -= minus0;
                    }
                }
            }

            std::cout << ans << "\n";
        }
    }

    return 0;
}
```

