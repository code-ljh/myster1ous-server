## S+20250819 CSP 模拟赛

致！第一次 AK！

致敬！第一次真正意义上的 $\text{RK}1$!!

```
1. Codeljh 100 100 100 100 400
2. ... 100 100 100 45 345
2. ... 100 100 100 45 345
...
```

感谢神仙！！！

### A. 逆转

题面长的一大堆，总结就是个红题，模拟即可。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 4096;

int scoreA, scoreB;
bool TA[N], TB[N];
int Diff[N];

signed main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    freopen("game.in", "r", stdin);
    freopen("game.out", "w", stdout);

    std::cin >> scoreA;
    for (int i = 0; i < scoreA; i++) {
        int ett;
        std::cin >> ett;
        TA[ett] = true;
    }

    std::cin >> scoreB;
    for (int i = 0; i < scoreB; i++) {
        int ett;
        std::cin >> ett;
        TB[ett] = true;
    }

    int curScoA = 0, curScoB = 0;
    for (int i = 1; i <= 2880; i++) {
        curScoA += TA[i];
        curScoB += TB[i];
        Diff[i] = curScoA - curScoB;
    }

    std::string state = "Nothing";
    int reverses = 0;
    for (int i = 1; i <= 2880; i++) {
        if (Diff[i] < 0) {
            if (state == "A-Leading")
                reverses += 1;
            state = "B-Leading";
        } else if (Diff[i] > 0) {
            if (state == "B-Leading")
                reverses += 1;
            state = "A-Leading";
        }
    }

    int sum = 0;
    for (int i = 1; i <= 1440; i++) sum += TA[i] + TB[i];

    std::cout << sum << std::endl;
    std::cout << reverses << std::endl;

    return 0;
}
```

### B. 约数计数

给定 $m$ 个整数 $a_1,...,a_m$，问对于 $x=[0,\dots,m]$，$[1,n]$ 中有多少个整数 $d$ 满足其是 $a$ 序列中恰好 $k$ 个数的约数。

乍一看很难，实际 $m\leqslant 200$，纯暴力因分即可。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 256;

int n, m;
int Arr[N], Ans[N];
std::map<int, int> Map;

signed main() {
    freopen("div.in", "r", stdin);
    freopen("div.out", "w", stdout);

    std::cin.tie(nullptr)->sync_with_stdio(false);

    std::cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        std::cin >> Arr[i];
        for (int j = 1; j * j <= Arr[i]; j++)
            if (Arr[i] % j == 0) {
                int div = j, div2 = Arr[i] / j;
                Map[div] += 1;
                if (div2 != div)
                    Map[div2] += 1;
            }
    }

    for (auto i : Map)
        if (i.first <= n)
            Ans[i.second] += 1;

    int sumAns = 0;
    for (int i = 1; i <= m; i++) sumAns += Ans[i];

    std::cout << n - sumAns << "\n";

    for (int i = 1; i <= m; i++) std::cout << Ans[i] << "\n";

    return 0;
}
```

### C. 集合查找

维护一个集合。

1. `1 x` 向集合中插入 $x$。
2. `2 x k s` 问在集合中且满足以下所有条件的所有 $u$ 中，能让 $u \boxplus x$ 达到最大的是哪个？

- 条件 $1$：$v \leqslant s - x$；
- 条件 $2$：$k | \gcd(x, u)$。

$x,k,s,q\leqslant 10^5$

首先，显然 $k|\gcd(x,u) \iff k|x $ 且 $k|u$。

于是，我们便可以对于每一个 $k$ 都维护一颗 $\text{01 Trie}$ 树，$\text{Trie}$ 树中维护子树的 $\min$，于是便可以解释条件 $1$ 了。然后贪心的按位选取即可。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 131072;
const int SQN = 384;
const int INF = 1ll << 40;

void Update(int& u, int with) {
    if (with < u)
        u = with;
}

int cases;
int operate, u, k, s;

bool InSet[N];

struct Trie {
    Trie* Son[2];
    int min, cnt;

    Trie() {
        Son[0] = nullptr;
        Son[1] = nullptr;
        min = INF, cnt = 0;
    }
} * T[SQN << 1];

signed main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    freopen("set.in", "r", stdin);
    freopen("set.out", "w", stdout);

    for (int i = 0; i < SQN << 1; i++) T[i] = new Trie();

    std::cin >> cases;

    while (cases--) {
        std::cin >> operate >> u;

        if (operate == 1) {
            InSet[u] = true;
            for (int i = 1; i <= SQN; i++)
                if (u % i == 0) {
                    Trie* p = T[i];
                    Update(T[i]->min, u);
                    T[i]->cnt += 1;
                    for (int j = 17; j >= 0; j--) {
                        int c = u >> j & 1;
                        if (!p->Son[c])
                            p->Son[c] = new Trie();
                        p = p->Son[c];
                        Update(p->min, u);
                        p->cnt += 1;
                    }
                }
        } else {
            std::cin >> k >> s;

            if (u % k != 0) {
                std::cout << "-1\n";
                continue;
            }

            int limit = s - u;
            if (k > SQN) {
                int maxor = -INF;
                int ansv = -1;
                for (int v = k; v < N; v += k)
                    if (InSet[v]) {
                        if (v > limit)
                            break;
                        if ((v ^ u) > maxor) {
                            maxor = v ^ u;
                            ansv = v;
                        }
                    }
                std::cout << ansv << "\n";
            } else {
                Trie* p = T[k];
                if (T[k]->min > limit) {
                    std::cout << "-1\n";
                } else {
                    int v = 0;
                    for (int j = 17; j >= 0; j--) {
                        int c = u >> j & 1;
                        if (p->Son[!c] && p->Son[!c]->min <= limit)
                            c = !c;
                        p = p->Son[c];
                        v ^= c << j;
                    }
                    std::cout << v << "\n";
                }
            }
        }
    }

    return 0;
}
```

### D. 公交路线

给定一棵 $n$ 个节点的树，树上有 $m$ 个路径，如果存在一个路径同时包含 $u,v$，则 $u$ 可以花费 $1$ 单位时间到 $v$，给定 $q$ 个询问，每次求 $a,b$ 之间的最短路。 

首先考虑链怎么做。

显然贪心的讲、越向右一定更好。因此我们可以对每个点维护一个 `nxt`，不断向右跳。可以通过倍增来优化。时间复杂度 $\mathcal{O}(n\log n)$。

如果在树上呢？询问的 $a,b$ 可以拆分成 $a\to \text{LCA}(a,b)\to b$，可以证明的是，经过其他点一定不优。因此我们仍然对每个点维护 `nxt`，不断向上跳，直到跳到 `lca`。

如果不能往上跳、再向上就越过 `lca` 了，如果此时 $a' \to b'$ 可直达则输出 $a,b$ 跳的次数 $-1$，否则直接将 $a,b$ 跳的次数输出即可。

如何判断 $u,v$ 是否可以直达？是否可以直达 $\iff$ 存在一个路径，左端点在 $u$ 子树、右端点 $v$ 子树，子树即区间，因此直接二维数点。

这题代码非常复杂 $400$ 行。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 131072;
const int LN = 32;
const int INF = (1ll << 30); 
const int NOSETTAG = INF;

int u, v;
int nodes, buses, queries;

std::vector<int> Tree[N];
int Fa[LN][N], Depth[N];
int Size[N], HSon[N]; 
int DFN[N], DList[N], cntDFN;
int CTop[N];

void InitTree(int u) {	
	Size[u] = 1;
	for (auto v : Tree[u]) 
		if (v != Fa[0][u]) {
			Fa[0][v] = u;
			Depth[v] = Depth[u] + 1;
			InitTree(v);
			
			Size[u] += Size[v];
			if (Size[v] > Size[HSon[u]])
				HSon[u] = v;
		}
}

void InitDecompose(int u) {
	DFN[u] = ++cntDFN;
	DList[cntDFN] = u;
	
	if (HSon[u]) {
		CTop[HSon[u]] = CTop[u];
		InitDecompose(HSon[u]);
		
		for (auto v : Tree[u])
			if (v != HSon[u] && v != Fa[0][u]) {
				CTop[v] = v;
				InitDecompose(v);
			}
	}
}

int LCA(int u, int v) {
	if (Depth[u] > Depth[v])
		std::swap(u, v);
	int d = Depth[v] - Depth[u];
	for (int i = 20; i >= 0; i--)
		if (d >> i & 1)
			v = Fa[i][v];
	if (v == u) 
		return v;
	for (int i = 20; i >= 0; i--)
		if (Fa[i][u] != Fa[i][v]) {
			u = Fa[i][u];
			v = Fa[i][v];
		}
	return Fa[0][u];
}

struct Busline {
	int u, v, lca;
	
	Busline() {
		u = 0; v = 0;
		lca = 0;
	}
	
	Busline(int a, int b) {
		u = a, v = b;
		lca = LCA(u, v);
	} 
	
	bool operator<(const Busline& o) 
	const& {
		int curkey = Depth[lca];
		int oookey = Depth[o.lca];
		return curkey > oookey;
	}
} VB[N];

std::vector<Busline*> ByLca[N];

std::vector<
	std::pair<int, int>> VTRes;

void VTDecompose(int u, int v) {
	VTRes.clear();
	while (CTop[u] != CTop[v]) 
		if (Depth[CTop[u]] < Depth[CTop[v]]) {
			VTRes.emplace_back(DFN[CTop[v]], DFN[v]);
			v = Fa[0][CTop[v]];
		} else {
			VTRes.emplace_back(DFN[CTop[u]], DFN[u]);
			u = Fa[0][CTop[u]];
		}
	if (Depth[u] > Depth[v]) std::swap(u, v);
	VTRes.emplace_back(DFN[u], DFN[v]);
} 

struct Segmentree {
	Segmentree* Son[2];
	int l, r, mid;
	int settag, sum;
	
	Segmentree(int ll, int rr) {
		l = ll, r = rr, mid = (l + r) / 2;
		settag = NOSETTAG;
		sum = 0;
		if (l != r) {
			Son[0] = new Segmentree(l, mid);
			Son[1] = new Segmentree(mid + 1, r);
		}
	}
	
	void pushup() {
		sum = Son[0]->sum + Son[1]->sum;
	}
	
	void set(int to) {
		if (to != NOSETTAG) {
			sum = (r - l + 1) * to;
			settag = to;
		}
	}
	
	void pushdown() {
		if (settag != NOSETTAG) {
			Son[0]->set(settag);
			Son[1]->set(settag);
			settag = NOSETTAG;
		}
	}
	
	void Modify(int ll, int rr, int to) {
		if (ll <= l && r <= rr) {
			set(to);
		} else {
			pushdown();
			if (ll <= mid) 
				Son[0]->Modify(ll, rr, to);
			if (mid < rr) 
				Son[1]->Modify(ll, rr, to);
			pushup();
		}
	}
	
	int Query(int ll, int rr) {
		if (ll <= l && r <= rr) {
			return sum;
		} else {
			pushdown();
			int ans = 0;
			if (ll <= mid) 
				ans += Son[0]->Query(ll, rr);
			if (mid < rr)
				ans += Son[1]->Query(ll, rr);
			return ans;
		}
	}
};

int Nxt[LN][N];
int Ans[N], Offl[N << 3];

struct Orixor {
	int add0, add1, add2, add3;
	int sub0, sub1, sub2, sub3;
} Anss[N];

struct Queries {
	int rx, ry, id;
	
	Queries() {
		rx = 0;
		ry = 0;
		id = 0;
	}
	
	Queries(int u, int v, int d) {
		rx = u;
		ry = v;
		id = d;
	}
	
	bool operator<(const Queries& o)
		const & {
			return rx < o.rx; 
		}
};

int sizeO;
std::pair<int, int> Offline[N << 3]; 
std::vector<Queries> VO;

std::pair<int, int> Points[N];
int Fenwick[N];	

void FWModify(int u, int k) {
//	if (u == 0) return 0;
	for (int i = u; i < N; i += i & -i)
		Fenwick[i] += k;
}

int FWQuery(int u) {
//	if (u == 0) return 0;
	int ans = 0;
	for (int i = u; i; i -= i & -i)
		ans += Fenwick[i];
	return ans;
}

/*

9 3 10
6 2
2 7
7 8
9 3
3 2
4 2
2 1
5 1

8 7
9 2
4 5

1 7
2 8
3 4
5 6
1 9
1 2
1 3
2 3
3 7
9 8

*/ 

signed main() {
	freopen("bus.in", "r", stdin);
	freopen("bus.out", "w", stdout);
	
	std::cin.tie(nullptr);
	std::cin.sync_with_stdio(false);
	
	std::cin >> nodes
		>> buses
		>> queries;
	
	for (int i = 1; i < nodes; i++) {
		std::cin >> u >> v;
		Tree[u].push_back(v);
		Tree[v].push_back(u);
	}
	
	InitTree(1);
	for (int i = 1; 1 << i <= nodes; i++)
		for (int j = 1; j <= nodes; j++)
			Fa[i][j] = Fa[i - 1][Fa[i - 1][j]];
	
	CTop[1] = 1;
	InitDecompose(1);
	
	for (int i = 1; i <= buses; i++) {
		int& u = VB[i].u, &v = VB[i].v;
		int& lca = VB[i].lca;
		std::cin >> u >> v;
		lca = LCA(u, v);
	}
	
	Segmentree *rt = new Segmentree(1, nodes);
	for (int i = 1; i <= nodes; i++)
		rt->Modify(i, i, DList[i]);
		
	std::sort(VB + 1, VB + buses + 1);
	for (int i = 1; i <= buses; i++) {
		int& u = VB[i].u, &v = VB[i].v;
		int& lca = VB[i].lca;
		VTDecompose(u, v);
		ByLca[lca].push_back(&VB[i]);
		for (auto j : VTRes)
			rt->Modify(j.first, j.second, lca);
	}
	
	for (int i = 1; i <= nodes; i++) 
		Nxt[0][i] = rt->Query(DFN[i], DFN[i]);
	
	for (int i = 1; 1 << i <= nodes; i++)
		for (int j = 1; j <= nodes; j++)
			Nxt[i][j] = Nxt[i - 1][Nxt[i - 1][j]];
	
	for (int i = 1; i <= queries; i++) {
		int u, v;
		std::cin >> u >> v;
		
		int lca = LCA(u, v);
		
		int sum = 0;
		for (int i = 20; i >= 0; i--) {
			if (Depth[Nxt[i][u]] > Depth[lca]) {
				sum += 1 << i;
				u = Nxt[i][u];
			}
			if (Depth[Nxt[i][v]] > Depth[lca]) {
				sum += 1 << i;
				v = Nxt[i][v];
			}
		}
		
//		std::cout << u << " " << v << " " << lca << "\n";
//		std::cout << sum << std::endl;
		if (Nxt[0][u] == u && u != lca) {
			Ans[i] = -1;
		} else if (Nxt[0][v] == v && v != lca) {
			Ans[i] = -1;
		} else {
			Ans[i] = sum;
			if (lca == u) {
				Ans[i] += Depth[Nxt[0][v]] > Depth[u];
			} else if (lca == v) {
				Ans[i] += Depth[Nxt[0][u]] > Depth[v];
			} else {
				int lu = DFN[u];
				int ru = DFN[u] + Size[u] - 1;
				int lv = DFN[v];
				int rv = DFN[v] + Size[v] - 1;
				Anss[i].add0 = sizeO + 1;
				Anss[i].add1 = sizeO + 2;
				Anss[i].add2 = sizeO + 3;
				Anss[i].add3 = sizeO + 4;
				Anss[i].sub0 = sizeO + 5;
				Anss[i].sub1 = sizeO + 6;
				Anss[i].sub2 = sizeO + 7;
				Anss[i].sub3 = sizeO + 8;
				Offline[++sizeO] = std::make_pair(ru, rv);
				Offline[++sizeO] = std::make_pair(lu - 1, lv - 1); 
				Offline[++sizeO] = std::make_pair(rv, ru);
				Offline[++sizeO] = std::make_pair(lv - 1, lu - 1); 
				Offline[++sizeO] = std::make_pair(ru, lv - 1);
				Offline[++sizeO] = std::make_pair(lu - 1, rv);
				Offline[++sizeO] = std::make_pair(rv, lu - 1);
				Offline[++sizeO] = std::make_pair(lv - 1, ru);
			}
		}
	}
	
//	for (int i = 1; i <= nodes; i++)
//		std::cout << Nxt[0][i] << " \n"[i == nodes];

	for (int i = 1; i <= buses; i++)
		Points[i] = std::make_pair(
			DFN[VB[i].u],
			DFN[VB[i].v]);
		
	std::sort(Points + 1, Points + buses + 1);
	
	for (int i = 1; i <= sizeO; i++)
		VO.emplace_back(Offline[i].first,
			Offline[i].second, i);
			
	std::sort(VO.begin(), VO.end());
	int id = 1;
	for (int i = 0; i < sizeO; i++) {
		while (Points[id].first <= VO[i].rx && id <= buses) {
			FWModify(Points[id].second, 1);
			id += 1;
		}
		Offl[VO[i].id] = FWQuery(VO[i].ry);
	}
			
	for (int i = 1; i <= queries; i++) {
		if (!Anss[i].add0) {
			std::cout << Ans[i] << "\n";			
		} else {
			int cnt = 0;
			cnt += Offl[Anss[i].add0];
			cnt += Offl[Anss[i].add1];
			cnt += Offl[Anss[i].add2];
			cnt += Offl[Anss[i].add3];
			cnt -= Offl[Anss[i].sub0];
			cnt -= Offl[Anss[i].sub1];
			cnt -= Offl[Anss[i].sub2];
			cnt -= Offl[Anss[i].sub3];
			std::cout << Ans[i] + bool(!cnt) << "\n"; 
		}
	} 
	
	return 0;
}
```